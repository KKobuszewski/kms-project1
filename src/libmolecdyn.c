#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#include <math.h>

#include "molecdyn.h"

typedef struct Global_t
{
    double a;
    double m;
    double T0;
    double f;
    double epsilon;
    double lm;
    uint32_t nx;
    uint32_t ny;
    uint32_t nz;
    uint32_t N;
    
    /* Arrays with data */
    double* x_arr;
    double* y_arr;
    double* z_arr;
    double* vx_arr;
    double* vy_arr;
    double* vz_arr;
    double* fx_arr;
    double* fy_arr;
    double* fz_arr;
} Global_t;

Global_t global;

// TODO: Move static inline functions to header in case to make them inline in other compilation units.
//       OR MOVE GLOBAL STRUCTRE TO MAKE IT VISIBLE IN OTHER COMPILATION UNITS

// ============== Set lattice methods ============================================ /

/*
 * This function set given coordinate of position vector for every particle.
 * param coord_arr - array of single coordinates of particle
 * param bi_coord - given coordinate of i-th base vector
 */
inline void vecCoordxbaseCoord(double* coord_arr, const double b1_coord, const double b2_coord, const double b3_coord)
{
    // TODO: Check if really quicker with register variables
    // TODO: Make use of vectorization and SIMD alignmnet!
    uint32_t register ixyz = 0;
    uint32_t register const nx = global.nx;
    uint32_t register const ny = global.ny;
    uint32_t register const nz = global.nz;
    //double register const n_dlb = (double)global.n;
    // TODO: Unroll this loop!
    // TODO: OpenMP
    for (uint32_t ix = 0; ix < nx; ix++)
    {
        for (uint32_t iy = 0; iy < ny; iy++)
        {
            for (uint32_t iz = 0; iz < nz; iz++)
            {
                //ixyz = ix + iy*nx + iz*ny*nx;
                coord_arr[ixyz] = (ix - (nx-1)/2.)*b1_coord + (iy - (ny-1)/2.)*b2_coord + (iz - (nz-1)/2.)*b3_coord;
                ixyz += 1;
            }
        }
    }
    
    // idea for unrolling:
//     uint32_t ix=0, iy=0, iz=0
//     for (uint32_t ii = 0; ii < nx*ny*nz; ii++)
//     {
//         coord_arr[ii] = (ix - (n-1)/2.)*b1_coord + (iy - (n-1)/2.)*b2_coord + (iz - (n-1)/2.)*b3_coord;
//         ix = (ix + 1)%nx;
//         iy = (iy + 1)%ny;
//         iz = (iz + 1)%nz;
//     }
}

// TODO: Declare enum
//enum base_indices {X,Y,Z};

/*
 * This function sets particles in a lattice generated by basis vectors base_veci.
 */
inline void set_lattice(double* base_vec1,
                        double* base_vec2,
                        double* base_vec3)
{
    // TODO: Make use of OpenMP and omp_set_nested!
    vecCoordxbaseCoord(global.x_arr, base_vec1[0], base_vec2[0], base_vec3[0]);
    vecCoordxbaseCoord(global.y_arr, base_vec1[1], base_vec2[1], base_vec3[1]);
    vecCoordxbaseCoord(global.z_arr, base_vec1[2], base_vec2[2], base_vec3[2]);
}

// ============= Draw velocities methods =================================================== /

inline void drawVelVecCoord(double* coord_arr)
{
    uint32_t register const N = global.nx*global.ny*global.nz;
    double register lm = global.lm;
    
    for (uint32_t ii = 0; ii < N; ii++)
    {
        //coord_arr[ii] = lm*(2*drand48() - 1);
        coord_arr[ii] = lm*(2*((double)rand()/((double)RAND_MAX)) - 1);
    }
}

// TODO: Add different distributions. MAXWELL-BOLTZMANN!
inline void set_velocities()
{
    drawVelVecCoord(global.vx_arr);
    drawVelVecCoord(global.vy_arr);
    drawVelVecCoord(global.vz_arr);
}

// ============= Count forces ============================================================== /



// ============= Count statistics ========================================================= /




// ============= Functions to be called out of library ===================================== /

void init_csimulation(   const double a,
                        const double m,
                        const double T0,
                        const double f,
                        const double epsilon,
                        const uint32_t nx,
                        const uint32_t ny,
                        const uint32_t nz,
                        double* base_vec1,
                        double* base_vec2,
                        double* base_vec3
                    )
{
    // Set parameters
    global.a = a;
    global.m = m;
    global.T0 = T0;
    global.f = f;
    global.epsilon = epsilon;
    global.nx = nx;
    global.ny = nz;
    global.nz = nz;
    global.N = nx*ny*nz;
    
    const double kb = 0.00831; // rescale temperature
    global.lm = sqrt(3.*T0*kb*1); // sqrt(3.*T0*kB*m) ale przyjmujemy do celow symulacji m = 1 <- przeskalowanie przy zwracaniu wynikÃ³w
    
    // TODO: Check if it wouldn't be quicker to make contigouous 3-array.
    // Alloc mem for positions' vector
    global.x_arr = (double*)malloc( sizeof(double) * nx*ny*nz );
    global.y_arr = (double*)malloc( sizeof(double) * nx*ny*nz );
    global.z_arr = (double*)malloc( sizeof(double) * nx*ny*nz );
    
    // Alloc mem for velocities' vector
    global.vx_arr = (double*)malloc( sizeof(double) * nx*ny*nz );
    global.vy_arr = (double*)malloc( sizeof(double) * nx*ny*nz );
    global.vz_arr = (double*)malloc( sizeof(double) * nx*ny*nz );
    
    // Alloc mem for forces' vector
    global.fx_arr = (double*)malloc( sizeof(double) * nx*ny*nz );
    global.fy_arr = (double*)malloc( sizeof(double) * nx*ny*nz );
    global.fz_arr = (double*)malloc( sizeof(double) * nx*ny*nz );
    
    set_lattice(base_vec1, base_vec2, base_vec3);
    
    set_velocities();
}

// rescale & return array
/*
 * Pointers on pointer to 1D array
 */
void get_data(double** x_arr_ptr, double** y_arr_ptr, double** z_arr_ptr, double** vx_arr_ptr, double** vy_arr_ptr, double** vz_arr_ptr)
{
    // copy arrays here with memcpy - copy now
    
    // positions
    memcpy( *x_arr_ptr, global.x_arr, global.N );
    memcpy( *y_arr_ptr, global.y_arr, global.N );
    memcpy( *z_arr_ptr, global.z_arr, global.N );
    
    // velocities
    memcpy( *vx_arr_ptr, global.vx_arr, global.N );
    memcpy( *vy_arr_ptr, global.vy_arr, global.N );
    memcpy( *vz_arr_ptr, global.vz_arr, global.N );
    
    // rescale with OpenMP
}

// copy pointers to data
double** return_positions()
{
    double** positions = (double**) malloc(3 * sizeof(double*));
    
    positions[0] = global.x_arr;
    positions[1] = global.y_arr;
    positions[2] = global.z_arr;
    
    return positions;
}
    