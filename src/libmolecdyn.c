#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#include <math.h>

#include "molecdyn.h"

typedef struct Global_t
{
    double a;
    double m;
    double T0;
    double f;
    double epsilon;
    double lm;
    double kb;
    uint32_t nx;
    uint32_t ny;
    uint32_t nz;
    uint32_t N;
    
    /* Arrays with data */
    double* x_arr;
    double* y_arr;
    double* z_arr;
    double* vx_arr;
    double* vy_arr;
    double* vz_arr;
    double* fx_arr;
    double* fy_arr;
    double* fz_arr;
} Global_t;

Global_t global;

// TODO: Move static inline functions to header in case to make them inline in other compilation units.
//       OR MOVE GLOBAL STRUCTRE TO MAKE IT VISIBLE IN OTHER COMPILATION UNITS

// ============== Set lattice methods ============================================ /

/*
 * This function set given coordinate of position vector for every particle.
 * param coord_arr - array of single coordinates of particle
 * param bi_coord - given coordinate of i-th base vector
 */
inline void vecCoordxbaseCoord(double* coord_arr, const double b1_coord, const double b2_coord, const double b3_coord)
{
    // TODO: Check if really quicker with register variables
    // TODO: Make use of vectorization and SIMD alignmnet!
    uint32_t register ixyz = 0;
    uint32_t register const nx = global.nx;
    uint32_t register const ny = global.ny;
    uint32_t register const nz = global.nz;
    //double register const n_dlb = (double)global.n;
    // TODO: Unroll this loop!
    // TODO: OpenMP
    for (uint32_t ix = 0; ix < nx; ix++)
    {
        for (uint32_t iy = 0; iy < ny; iy++)
        {
            for (uint32_t iz = 0; iz < nz; iz++)
            {
                //ixyz = ix + iy*nx + iz*ny*nx;
                coord_arr[ixyz] = (ix - (nx-1)/2.)*b1_coord + (iy - (ny-1)/2.)*b2_coord + (iz - (nz-1)/2.)*b3_coord;
                ixyz += 1;
            }
        }
    }
    
    // idea for unrolling:
//     uint32_t ix=0, iy=0, iz=0
//     for (uint32_t ii = 0; ii < nx*ny*nz; ii++)
//     {
//         coord_arr[ii] = (ix - (n-1)/2.)*b1_coord + (iy - (n-1)/2.)*b2_coord + (iz - (n-1)/2.)*b3_coord;
//         ix = (ix + 1)%nx;
//         iy = (iy + 1)%ny;
//         iz = (iz + 1)%nz;
//     }
}

// TODO: Declare enum
//enum base_indices {X,Y,Z};

/*
 * This function sets particles in a lattice generated by basis vectors base_veci.
 */
inline void set_lattice(double* base_vec1,
                        double* base_vec2,
                        double* base_vec3)
{
    // TODO: Make use of OpenMP and omp_set_nested!
    vecCoordxbaseCoord(global.x_arr, base_vec1[0], base_vec2[0], base_vec3[0]);
    vecCoordxbaseCoord(global.y_arr, base_vec1[1], base_vec2[1], base_vec3[1]);
    vecCoordxbaseCoord(global.z_arr, base_vec1[2], base_vec2[2], base_vec3[2]);
}

// ============= Draw velocities methods =================================================== /

inline void drawVelVecCoordUniform(double* coord_arr)
{
    register const uint32_t N = global.nx*global.ny*global.nz;
    register const double lm = global.lm;
    
    for (uint32_t ii = 0; ii < N; ii++)
    {
        //coord_arr[ii] = lm*(2*drand48() - 1);
        coord_arr[ii] = lm*(2*((double)rand()/((double)RAND_MAX)) - 1);
    }
}

// TODO: Better random number generator
inline void drawVelVecCoordBoltzmann(double* coord_arr)
{
    register const uint32_t N = global.nx*global.ny*global.nz;
    register const double lm = global.lm;
    
    for (uint32_t ii = 0; ii < N; ii++)
    {
        double X = ((double)rand() + 1.)/((double)RAND_MAX + 1.); // random number in (0,1]
        double sign = (1. - 2.*(rand()%2)); // random sign
        coord_arr[ii] = sign * sqrt(m*kb*T0 * ((-1.)*log(X))); // \pm \sqrt{2 m E_k}
    }
}

typedef enum {UNIFORM, BOLTZMANN} distribution_t;

// draw velocities from chosen distribution
inline void drawVelVecCoord(double* coord_arr, distribution_t distribution)
{
    if      (distribution == BOLTZMANN) drawVelVecCoordBoltzmann(coord_arr);
    else if (distribution == UNIFORM  ) drawVelVecCoordUniform(coord_arr);
}

inline double mean_momentum()
{
    for (uint32_t ii=0; ii<0; ii++)
    {
        
    }
}

// TODO: Add different distributions. MAXWELL-BOLTZMANN!
inline void set_velocities()
{
    drawVelVecCoord(global.vx_arr, BOLTZMANN);
    drawVelVecCoord(global.vy_arr, BOLTZMANN);
    drawVelVecCoord(global.vz_arr, BOLTZMANN);
}

// ============= Count forces ============================================================== /

// http://chemwiki.ucdavis.edu/Physical_Chemistry/Physical_Properties_of_Matter/Intermolecular_Forces/Lennard-Jones_Potential


// ============= Count statistics ========================================================= /




// ============= Functions to be called out of library ===================================== /

void init_csimulation(   const double a,
                        const double m,
                        const double T0,
                        const double f,
                        const double epsilon,
                        const uint32_t nx,
                        const uint32_t ny,
                        const uint32_t nz,
                        double* base_vec1,
                        double* base_vec2,
                        double* base_vec3
                    )
{
    // Set parameters
    global.a = a;
    global.m = m;
    global.T0 = T0;
    global.f = f;
    global.epsilon = epsilon;
    global.nx = nx;
    global.ny = nz;
    global.nz = nz;
    global.N = nx*ny*nz;
    global.kb = 0.00831;
    global.lm = sqrt(3.*T0*0.00831*m); // sqrt(3.*T0*kB*m) ale przyjmujemy do celow symulacji m = 1 <- przeskalowanie przy zwracaniu wynikÃ³w
    
    // TODO: Check if it wouldn't be quicker to make contigouous 3-array.
    // Alloc mem for positions' vector
    global.x_arr = (double*)malloc( sizeof(double) * nx*ny*nz );
    global.y_arr = (double*)malloc( sizeof(double) * nx*ny*nz );
    global.z_arr = (double*)malloc( sizeof(double) * nx*ny*nz );
    
    // Alloc mem for velocities' vector
    global.vx_arr = (double*)malloc( sizeof(double) * nx*ny*nz );
    global.vy_arr = (double*)malloc( sizeof(double) * nx*ny*nz );
    global.vz_arr = (double*)malloc( sizeof(double) * nx*ny*nz );
    
    // Alloc mem for forces' vector
    global.fx_arr = (double*)malloc( sizeof(double) * nx*ny*nz );
    global.fy_arr = (double*)malloc( sizeof(double) * nx*ny*nz );
    global.fz_arr = (double*)malloc( sizeof(double) * nx*ny*nz );
    
    // NOTE: Assuming vectors are normalized!
    for (int ii=0; ii < 3; ii++)
    {
        base_vec1[ii] *= a;
	base_vec2[ii] *= a;
	base_vec3[ii] *= a;
    }
    set_lattice(base_vec1, base_vec2, base_vec3);
    
    set_velocities();
}

// copy pointers to data
double** return_positions()
{
    double** positions = (double**) malloc(3 * sizeof(double*));
    
    positions[0] = global.x_arr;
    positions[1] = global.y_arr;
    positions[2] = global.z_arr;
    
    return positions;
}

double** return_velocities()
{
    double** velocities = (double**) malloc(3 * sizeof(double*));
    
    velocities[0] = global.vx_arr;
    velocities[1] = global.vy_arr;
    velocities[2] = global.vz_arr;
    
    return velocities;
}

double** return_forces()
{
    double** forces = (double**) malloc(3 * sizeof(double*));
    
    forces[0] = global.fx_arr;
    forces[1] = global.fy_arr;
    forces[2] = global.fz_arr;
    
    return forces;
}

void free_mem()
{
    
    free(global.x_arr);
    free(global.y_arr);
    free(global.z_arr);
    
    free(global.vx_arr);
    free(global.vy_arr);
    free(global.vz_arr);
    
    free(global.fx_arr);
    free(global.fy_arr);
    free(global.fz_arr);
    
}