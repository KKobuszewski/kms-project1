#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#include <math.h>
#include <omp.h>

#include "molecdyn.h"

#define M_PI 3.141592653589793


Global_t global;

double* initial_x_arr = NULL;
double* initial_y_arr = NULL;
double* initial_z_arr = NULL;

double* wrk_arr1 = NULL;
double* wrk_arr2 = NULL;
double* wrk_arr3 = NULL;

// TODO: Move static inline functions to header in case to make them inline in other compilation units.
//       OR MOVE GLOBAL STRUCTRE TO MAKE IT VISIBLE IN OTHER COMPILATION UNITS

// ============== Set lattice methods ============================================ /

/*
 * This function set given coordinate of position vector for every particle.
 * param coord_arr - array of single coordinates of particle
 * param bi_coord - given coordinate of i-th base vector
 */
inline void vecCoordxbaseCoord(double* coord_arr, const double b1_coord, const double b2_coord, const double b3_coord)
{
    // TODO: Check if really quicker with register variables
    // TODO: Make use of vectorization and SIMD alignmnet!
    uint32_t ixyz = 0;
    const uint32_t nx = global.nx;
    const uint32_t ny = global.ny;
    const uint32_t nz = global.nz;
    //double register const n_dlb = (double)global.n;
    // TODO: Unroll this loop!
    // TODO: OpenMP
    for (uint16_t ix = 0; ix < nx; ix++)
    {
        for (uint16_t iy = 0; iy < ny; iy++)
        {
            for (uint16_t iz = 0; iz < nz; iz++)
            {
                //ixyz = ix + iy*nx + iz*ny*nx;
                coord_arr[ixyz] = (ix - (nx-1)/2.)*b1_coord + (iy - (ny-1)/2.)*b2_coord + (iz - (nz-1)/2.)*b3_coord;
                ixyz += 1;
            }
        }
    }
    
    // idea for unrolling:
//     uint32_t ix=0, iy=0, iz=0
//     for (uint16_t ii = 0; ii < nx*ny*nz; ii++)
//     {
//         coord_arr[ii] = (ix - (n-1)/2.)*b1_coord + (iy - (n-1)/2.)*b2_coord + (iz - (n-1)/2.)*b3_coord;
//         ix = (ix + 1)%nx;
//         iy = (iy + 1)%ny;
//         iz = (iz + 1)%nz;
//     }
}


/*
 * This function sets particles in a lattice generated by basis vectors base_veci.
 */
inline void set_lattice(double* base_vec1, double* base_vec2, double* base_vec3)
{
    // TODO: Make use of OpenMP and omp_set_nested!
    vecCoordxbaseCoord(global.x_arr, base_vec1[X], base_vec2[X], base_vec3[X]);
    vecCoordxbaseCoord(global.y_arr, base_vec1[Y], base_vec2[Y], base_vec3[Y]);
    vecCoordxbaseCoord(global.z_arr, base_vec1[Z], base_vec2[Z], base_vec3[Z]);
    
    for (uint16_t ii = 0; ii < global.N; ii++)
    {
        initial_x_arr[ii] = global.x_arr[ii];
        initial_y_arr[ii] = global.y_arr[ii];
        initial_z_arr[ii] = global.z_arr[ii];
    }
}

// TODO:
// Find distance from initial position


// ============= Momentum methods =================================================== /

//typedef enum {UNIFORM, BOLTZMANN} distribution_t; // declared in molecdyn.h file

inline void drawMomVecCoordUniform(double* coord_arr)
{
    register const uint32_t N = global.nx*global.ny*global.nz;
    register const double lm = global.lm;
    
    for (uint16_t ii = 0; ii < N; ii++)
    {
        coord_arr[ii] = lm*(2*((double)rand()/((double)RAND_MAX)) - 1);
    }
}

// TODO: Better random number generator
inline void drawMomVecCoordBoltzmann(double* coord_arr)
{
    register const uint32_t N = global.nx*global.ny*global.nz;
    register const double m = global.m;
    register const double kb = global.kb;
    register const double T0 = global.T0;
        
    for (register uint32_t ii = 0; ii < N; ii++)
    {
        // TODO: Check if float wouldn`t be precise enough
        register double X = ((double)rand() + 1.)/((double)RAND_MAX + 1.); // random number in (0,1]
        register double sign = (1. - 2.*(rand()%2)); // random sign
        coord_arr[ii] = sign * sqrt(m*kb*T0 * ((-1.)*log(X))); // \pm \sqrt{2 m E_k}
    }
}


// draw momentum from chosen distribution
inline void drawMomVecCoord(double* coord_arr, distribution_t distribution)
{
    if      (distribution == BOLTZMANN) drawMomVecCoordBoltzmann(coord_arr);
    else if (distribution == UNIFORM  ) drawMomVecCoordUniform(coord_arr);
}

inline void set_mean_momentum_zero()
{
    register const uint32_t N = global.nx*global.ny*global.nz;
    
    double mean_momentum[3];
    mean_momentum[X] = 0.;
    mean_momentum[Y] = 0.;
    mean_momentum[Z] = 0.;
    
    // TODO: reduction with OpenMP
    for (register uint32_t ii=0; ii<N; ii++)
    {
        mean_momentum[X] += global.px_arr[ii];
    }
    for (register uint32_t ii=0; ii<N; ii++)
    {
        mean_momentum[Y] += global.py_arr[ii];
    }
    for (register uint32_t ii=0; ii<N; ii++)
    {
        mean_momentum[Z] += global.pz_arr[ii];
    }
    
    mean_momentum[X] /= (double)N;
    mean_momentum[Y] /= (double)N;
    mean_momentum[Z] /= (double)N;
    
    // TODO: Check which is quicker
    
    for (register uint32_t ii=0; ii<N; ii++)
    {
        global.px_arr[ii] -= mean_momentum[X];
        global.py_arr[ii] -= mean_momentum[Y];
        global.pz_arr[ii] -= mean_momentum[Z];
    }
#ifdef VEROBSE
    printf("# MEAN MOMENTUM AFTER DRAWING\n");
    printf("(%5.5lf, %5.5lf, %5.5lf)\n",mean_momentum[X],mean_momentum[Y],mean_momentum[Z]);
#endif
}

// TODO: Add different distributions. MAXWELL-BOLTZMANN!
inline void set_momenta()
{
    drawMomVecCoord(global.px_arr, BOLTZMANN);
    drawMomVecCoord(global.py_arr, BOLTZMANN);
    drawMomVecCoord(global.pz_arr, BOLTZMANN);
//     drawMomVecCoord(global.px_arr, UNIFORM);
//     drawMomVecCoord(global.py_arr, UNIFORM);
//     drawMomVecCoord(global.pz_arr, UNIFORM);
        
    set_mean_momentum_zero();
}

// ============= Count forces ============================================================== /

// http://chemwiki.ucdavis.edu/Physical_Chemistry/Physical_Properties_of_Matter/Intermolecular_Forces/Lennard-Jones_Potential
inline void count_forces()
{
    const uint32_t N = global.nx*global.ny*global.nz;
    
    // clear momory - TODO: look if this is quicker than for
//     memset(global.fx_arr,0,N*sizeof(double));
//     memset(global.fy_arr,0,N*sizeof(double));
//     memset(global.fz_arr,0,N*sizeof(double));
    for( uint32_t ii=0; ii<N; ii++)
    {
        global.fx_arr[ii] = 0.;
        global.fy_arr[ii] = 0.;
        global.fz_arr[ii] = 0.;
    }
    
    // interatomic forces
    const double R_sq = global.R*global.R;
    const double epsilon = global.epsilon;double rij_sq;
    double xij;
    double yij;
    double zij;
    double F;
//     double fx_ij = 0.;
//     double fy_ij = 0.;
//     double fz_ij = 0.;
    
    uint32_t ii,jj;
    //#pragma omp parallel for num_threads(7) private(ii,jj)
    // TODO: Check if this is symmetric
    for (ii = 0; ii < N; ii++)
    {
        for (jj = ii+1; jj < N; jj++)
        {
            
            xij = global.x_arr[ii] - global.x_arr[jj];
            yij = global.y_arr[ii] - global.y_arr[jj];
            zij = global.z_arr[ii] - global.z_arr[jj];
            
            rij_sq = xij*xij + yij*yij + zij*zij;
            if (rij_sq < 1e-15) {printf("Lennard-Jones Force error! rij is %lf\n",rij_sq); /*exit(EXIT_FAILURE);*/}
            F = 12*epsilon*( pow(R_sq/rij_sq,6) - pow(R_sq/rij_sq,3) )/rij_sq;
            
            
            
            global.fx_arr[jj] -= F * xij;
            global.fy_arr[jj] -= F * yij;
            global.fz_arr[jj] -= F * zij;
            
            global.fx_arr[ii] += F * xij;
            global.fy_arr[ii] += F * yij;
            global.fz_arr[ii] += F * zij;
            
        }
    }
    
    // springiness forces
    const double f = global.f;
    const double L = global.L;
    double ri;
    double xi;
    double yi;
    double zi;
    double S;
    for (uint16_t ii = 0; ii < N; ii++)
    {
        xi = global.x_arr[ii];
        yi = global.y_arr[ii];
        zi = global.z_arr[ii];
            
        ri = sqrt(xi*xi + yi*yi + zi*zi);
        if (ri >= L)
        {
            S = f*(L-ri)/ri;
            global.fx_arr[ii] += S * xi;
            global.fy_arr[ii] += S * yi;
            global.fz_arr[ii] += S * zi;
#ifdef VERBOSE
            printf("r%d:\t%lf\t%lf\t\tforce:(%lf,%lf,%lf)\n",ii,ri,S,global.fx_arr[ii],global.fy_arr[ii],global.fz_arr[ii]);
#endif
        }
    }
}

// ============= Algorithm ============================================================== /

/*
 * NOTE: Assumes forces have been counted before! Important when initializing for the fist time
 */
inline void leap_frog()
{
    const uint32_t N = global.nx*global.ny*global.nz;
    const double half_dt = 0.5*global.dt;
    const double half_m = 0.5*global.m;
    
    
    // count forces for old positions
    //count_forces();
    
    // count momenta
    #pragma omp parallel num_threads(3) shared(global)
    #pragma omp sections
    {
        #pragma omp section
        {
            #pragma omp parallel for num_threads(2) shared(global)
            for (uint16_t ii = 0; ii < N; ii++)
            {
                global.px_arr[ii] += global.fx_arr[ii]*half_dt;
            }
        }
        #pragma omp section
        {
            #pragma omp parallel for num_threads(2) shared(global)
            for (uint16_t ii = 0; ii < N; ii++)
            {
                global.py_arr[ii] += global.fy_arr[ii]*half_dt;
            }
        }
        #pragma omp section
        {
            #pragma omp parallel for num_threads(2) shared(global)
            for (uint16_t ii = 0; ii < N; ii++)
            {
                global.pz_arr[ii] += global.fz_arr[ii]*half_dt;
            }
        }
    }
    
    // update positions
    #pragma omp parallel num_threads(3) shared(global)
    #pragma omp sections
    {
        #pragma omp section
        {
            #pragma omp parallel for num_threads(2) shared(global)
            for (uint16_t ii = 0; ii < N; ii++)
            {
                global.x_arr[ii] += global.px_arr[ii]*half_dt/half_m;
            }
        }
        #pragma omp section
        {
            #pragma omp parallel for num_threads(2) shared(global)
            for (uint16_t ii = 0; ii < N; ii++)
            {
                global.y_arr[ii] += global.py_arr[ii]*half_dt/half_m;
            }
        }
        #pragma omp section
        {
            #pragma omp parallel for num_threads(2) shared(global)
            for (uint16_t ii = 0; ii < N; ii++)
            {
                global.z_arr[ii] += global.pz_arr[ii]*half_dt/half_m;
            }
        }
    }
    
    
    
    // update forces
    count_forces();
    
    // update momenta
    #pragma omp parallel num_threads(3) shared(global)
    #pragma omp sections
    {
        #pragma omp section
        {
            #pragma omp parallel for num_threads(2) shared(global)
            for (uint16_t ii = 0; ii < N; ii++)
            {
                global.px_arr[ii] += global.fx_arr[ii]*half_dt;
            }
        }
        #pragma omp section
        {
            #pragma omp parallel for num_threads(2) shared(global)
            for (uint16_t ii = 0; ii < N; ii++)
            {
                global.py_arr[ii] += global.fy_arr[ii]*half_dt;
            }
        }
        #pragma omp section
        {
            #pragma omp parallel for num_threads(2) shared(global)
            for (uint16_t ii = 0; ii < N; ii++)
            {
                global.pz_arr[ii] += global.fz_arr[ii]*half_dt;
            }
        }
    }
    
    
    if (!global.x_arr[0]) printf("\n\n# %lf in LEAP FROG !!!!!!!!!!!\n\n",global.x_arr[0]);
}

// ============= Count statistics ========================================================= /

inline double kinetic_energy()
{
    const uint32_t N = global.nx*global.ny*global.nz;
    double T = 0.;
    
    // TODO: Optimization via 3 worker arrays? and 3 OpenMP Sections
    
    // Reduction with OpenMP
    for (uint16_t ii = 0; ii < N; ii++)
    {
        // here counting \sum_{i=1}^{N} {p_i}^2
        T += global.px_arr[ii]*global.px_arr[ii] + global.py_arr[ii]*global.py_arr[ii] + global.pz_arr[ii]*global.pz_arr[ii];
    }
    
    // here dividing by 2m
    return 0.5*T/global.m;
}

inline double temperature()
{
    const uint32_t N = global.nx*global.ny*global.nz;
    double T = 0.;
    
    for (uint16_t ii=0; ii < N; ii++)
    {
        T += global.px_arr[ii]*global.px_arr[ii] + global.py_arr[ii]*global.py_arr[ii] + global.pz_arr[ii]*global.pz_arr[ii];
    }
    
    return T/( 3*N*global.kb*global.m );
}

inline double temperature_from_kinetic(const double T)
{
    return 2.*T/(3*global.N*global.kb);
}


inline double LJ_potential()
{
    const uint32_t N = global.nx*global.ny*global.nz;
    const double R_sq = global.R*global.R;
    const double epsilon = global.epsilon;
    double rij_sq;
    double xij;
    double yij;
    double zij;
    double V_LJ = 0.;
    
    for (uint16_t ii = 0; ii < N; ii++)
    {
        for (uint16_t jj = 0; jj < ii; jj++)
        {
            xij = global.x_arr[ii] - global.x_arr[jj];
            yij = global.y_arr[ii] - global.y_arr[jj];
            zij = global.z_arr[ii] - global.z_arr[jj];
            
            rij_sq = xij*xij + yij*yij + zij*zij;
            rij_sq = R_sq/rij_sq;
            
            V_LJ += ( pow(rij_sq,6) - 2.*pow(rij_sq,3) );
        }
    }
    
    return epsilon*V_LJ;
}


inline double springiness_potential()
{
    const uint32_t N = global.nx*global.ny*global.nz;
    double V_sp = 0.;
    const double L = global.L;
    double ri;
    
    // TODO: omp redution with condition?
    for (uint16_t ii = 0; ii < N; ii++)
    {
        ri = sqrt(global.x_arr[ii]*global.x_arr[ii] + global.y_arr[ii]*global.y_arr[ii] + global.z_arr[ii]*global.z_arr[ii]);
        if (ri >= L)
        {
#ifdef VERBOSE
            printf("r%d:\t%lf\n",ii,ri);
#endif
            V_sp += (ri - L)*(ri - L);
        }
    }
#ifdef VERBOSE
    printf("# ###### Springiness potential %lf\n",0.5*global.f*V_sp);
#endif
    return 0.5*global.f*V_sp;
}


inline double pressure()
{
    const uint32_t N = global.nx*global.ny*global.nz;
    const double L = global.L;
    const double four_pi_L_sq = 4.*M_PI*global.L*global.L;
    double ri;
    double P =0.;
    
    // TODO: OpenMP reduction
    for (uint16_t ii = 0; ii < N; ii++)
    {
        ri = sqrt(global.x_arr[ii]*global.x_arr[ii] + global.y_arr[ii]*global.y_arr[ii] + global.z_arr[ii]*global.z_arr[ii]);
        if (ri >= L)
        {
            P += (ri - L);
        }
    }
    
    return global.f*P/four_pi_L_sq;
}

// ============= Functions to be called out of library ===================================== /

void init_csimulation(  const double a,
                        const double R,
                        const double m,
                        const double T0,
                        const double epsilon,
                        const double f,
                        const double L,
                        const double dt,
                        const uint32_t nx,
                        const uint32_t ny,
                        const uint32_t nz,
                        double* base_vec1,
                        double* base_vec2,
                        double* base_vec3
                    )
{
    // Set parameters
    global.a = a;
    global.R = R;
    global.m = m;
    global.dt = dt;
    global.T0 = T0;
    global.epsilon = epsilon;
    global.f = f;
    global.L = L;
    global.nx = nx;
    global.ny = nz;
    global.nz = nz;
    global.N = nx*ny*nz;
    global.kb = 0.00831;
    global.lm = sqrt(3.*T0*0.00831*m); // sqrt(3.*T0*kB*m) ale przyjmujemy do celow symulacji m = 1 <- przeskalowanie przy zwracaniu wynikÃ³w
    
    // enable omp nested threads
    omp_set_nested(1);
    
    // Memory allocation
    // TODO: Check if it wouldn't be quicker to make contigouous 3-array?
    // TODO: Condition for allocating additinal memory?
    #pragma omp parallel num_threads(3) shared(global)
    #pragma omp sections
    {
        // Alloc mem for positions' vector
        #pragma omp section
        {
            global.x_arr = (double*)malloc( sizeof(double) * nx*ny*nz );
            global.y_arr = (double*)malloc( sizeof(double) * nx*ny*nz );
            global.z_arr = (double*)malloc( sizeof(double) * nx*ny*nz );
            
            initial_x_arr = (double*)malloc( sizeof(double) * nx*ny*nz );
        }
        
        // Alloc mem for momenta's vector
        #pragma omp section
        {
            global.px_arr = (double*)malloc( sizeof(double) * nx*ny*nz );
            global.py_arr = (double*)malloc( sizeof(double) * nx*ny*nz );
            global.pz_arr = (double*)malloc( sizeof(double) * nx*ny*nz );
            
            initial_y_arr = (double*)malloc( sizeof(double) * nx*ny*nz );
        }
        
        // Alloc mem for forces' vector
        #pragma omp section
        {
            global.fx_arr = (double*)malloc( sizeof(double) * nx*ny*nz );
            global.fy_arr = (double*)malloc( sizeof(double) * nx*ny*nz );
            global.fz_arr = (double*)malloc( sizeof(double) * nx*ny*nz );
            
            initial_z_arr = (double*)malloc( sizeof(double) * nx*ny*nz );
        }
    } // end parallel sections
    
    // Additional worker arrays
    //wrk_arr1 = (double*)malloc( sizeof(double) * nx*ny*nz );
    //wrk_arr2 = (double*)malloc( sizeof(double) * nx*ny*nz );
    
#ifdef VERBOSE
    printf("# CONSTRUCTING LATTICE %ux%ux%u\n",nx,ny,nz);
    printf("lattice constant:  %lf\n",a);
    printf("lattice will be constucted on base vectors: \n");
    printf("(%1.3lf,%1.3lf,%1.3lf)\n",base_vec1[0],base_vec1[1],base_vec1[2]);
    printf("(%1.3lf,%1.3lf,%1.3lf)\n",base_vec2[0],base_vec2[1],base_vec2[2]);
    printf("(%1.3lf,%1.3lf,%1.3lf)\n",base_vec3[0],base_vec3[1],base_vec3[2]);
#endif
    
    // NOTE: Assuming vectors are normalized!
    for (int ii=0; ii < 3; ii++)
    {
        global.base_vec1[ii] = a*base_vec1[ii];
	global.base_vec2[ii] = a*base_vec2[ii];
	global.base_vec3[ii] = a*base_vec3[ii];
    }
    set_lattice(global.base_vec1, global.base_vec2, global.base_vec3);
    
    set_momenta();
}

/*
 * This function clears positions of atoms and sets them in intial positions
 */
void reset_lattice()
{
    const uint32_t N = global.nx*global.ny*global.nz;
    //const double a = global.a;
    // NOTE: Assuming vectors are normalized! <- DON'T DO THAT SECOND TIME
    /*for (int ii=0; ii < 3; ii++)
    {
        base_vec1[ii] *= a;
	base_vec2[ii] *= a;
	base_vec3[ii] *= a;
    }*/
    
    memset(global.x_arr,0,N*sizeof(double));
    memset(global.y_arr,0,N*sizeof(double));
    memset(global.z_arr,0,N*sizeof(double));
    
    memset(global.px_arr,0,N*sizeof(double));
    memset(global.py_arr,0,N*sizeof(double));
    memset(global.pz_arr,0,N*sizeof(double));
    
    memset(global.fx_arr,0,N*sizeof(double));
    memset(global.fy_arr,0,N*sizeof(double));
    memset(global.fz_arr,0,N*sizeof(double));
    
    set_lattice(global.base_vec1, global.base_vec2, global.base_vec3);
    set_momenta();
}

/*
 * This functions changes base vectors, scales them with a and set atoms in initial position.
 * NOTE: Assuming base vectors are normalized!
 */
void change_lattice(double* base_vec1, double* base_vec2, double* base_vec3)
{
    const double a = global.a;
    
    for (int ii=0; ii < 3; ii++)
    {
        global.base_vec1[ii] = a*base_vec1[ii];
	global.base_vec2[ii] = a*base_vec2[ii];
	global.base_vec3[ii] = a*base_vec3[ii];
    }
    
    reset_lattice();
}

void change_a(const double a, double* base_vec1, double* base_vec2, double* base_vec3)
{
    global.a = a;
    
    change_lattice(base_vec1, base_vec2, base_vec3);
}

void change_R(const double R)
{
    global.R = R;
}

void change_T(const double T0)
{
    global.T0 = T0;
    set_momenta();
}

// copy pointers to data
double** return_positions()
{
    double** positions = (double**) malloc(3 * sizeof(double*));
    
    positions[0] = global.x_arr;
    positions[1] = global.y_arr;
    positions[2] = global.z_arr;
    
    return positions;
}

double** return_momenta()
{
    double** momenta = (double**) malloc(3 * sizeof(double*));
    
    momenta[0] = global.px_arr;
    momenta[1] = global.py_arr;
    momenta[2] = global.pz_arr;
    
    return momenta;
}

double** return_forces()
{
    double** forces = (double**) malloc(3 * sizeof(double*));
    
    count_forces();
    
    forces[0] = global.fx_arr;
    forces[1] = global.fy_arr;
    forces[2] = global.fz_arr;
    
    return forces;
}

double* get_statistics()
{
    //kinetic energy, LJ potential energy, springiness potential energy, pressure, instantaneous tempretature
//     double* stats = (double*) malloc( (INST_TEMP+1) * sizeof(double) ); // to nice extending for another constants
    double* stats = (double*) malloc( (5) * sizeof(double) ); // to nice extending for another constants
    
    stats[0] = kinetic_energy();
#ifdef VERBOSE
    printf("kinetic: %lf\n",stats[0]);
#endif
    stats[1] = LJ_potential();
#ifdef VERBOSE
    printf("Lj     : %lf\n",stats[1]);
#endif
    stats[2] = springiness_potential();
#ifdef VERBOSE
    printf("spring : %lf\n",stats[2]);
#endif
    stats[3] = pressure();
#ifdef VERBOSE
    printf("press. : %lf\n",stats[3]);
#endif
    //stats[4] = temperature();
    stats[4] = temperature_from_kinetic(stats[0]);
#ifdef VERBOSE
    printf("temp.  : %lf\n",stats[4]);
#endif
    
    return stats;
}

void set_dt(const double dt)
{
    global.dt = dt;
#ifdef VERBOSE
    printf("Changing dt: %lf !!!\n",global.dt);
#endif
}


/*
 * Perform simulation for arbitrary time of 3ps to termalize
 */
void termalize_system()
{
    const uint16_t time = 3; // time in ps
    const uint16_t timesteps = time*( (uint16_t) round(1./global.dt) );
    
    printf("# TERMALIZATION\n");
    printf("Performing termalization for %d timesteps with dt=%e [%.1lf ps]\n",timesteps,global.dt,(double) time);
    
    count_forces(); // function leap_frog() requries
    
    for (uint16_t ii=0; ii < timesteps; ii++)
    {
        leap_frog();
    }
    
    printf("Termalization done\n");
    printf("\n");
}


void evolve_system(uint32_t timesteps)
{
    
    /* ******************************************* *
     *          MAIN LOOP
     */
    
    count_forces(); // function leap_frog() requries
    
    for (uint16_t ii=0; ii < timesteps; ii++)
    {
        leap_frog();
    }
}



/*
 * 
 * 
 */
void perform_experiment(double time, uint16_t steps_per_stats, uint16_t steps_per_positions)
{
    uint16_t timesteps = time*( (uint16_t) round(1./global.dt) );
    
//     double*     pressure_arr = malloc( timesteps * sizeof(double) );
//     double* sig_pressure_arr = malloc( timesteps * sizeof(double) );
//     double*     temp_arr     = malloc( timesteps * sizeof(double) );
//     double* sig_temp_arr     = malloc( timesteps * sizeof(double) );
    
    
    // ====================== FILES ==============================================
    /*
    //get current date
    char datetime[20];
    time_t t;
    time(&t);
    strftime(datetime, sizeof(datetime), "%F_%T", localtime(&t));
    */
    
    char dirname[256];
    sprintf( dirname,"Dane_dt=%e",global.dt);
    struct stat st = {0};
    if (stat(dirname, &st) == -1) { mkdir(dirname, 0777); }
    
    char filename_stats[256];
    sprintf( filename_pT,"pT_stats_T0=%.1lf.txt",global.T0);
    FILE* file_pT = fopen(filename_stats,"w");
    
    char filename_stats[256];
    sprintf( filename_stats,"%s/stats_T0=%.1lf.txt",dirname,global.T0);
    FILE* file_stats = fopen(filename_stats,"w");
    
    char filename_positions[256];
    sprintf( filename_positions,"%s/positions_T0=%.1lf.bin",dirname,global.T0);
    FILE* file_pos = fopen(filename_stats,"wb");
    
    char filename_momenta[256];
    sprintf( filename_momenta,"%s/momenta_T0=%.1lf.bin",dirname,global.T0);
    FILE* file_mom = fopen(filename_stats,"wb");
    
    
    // ============================= MAIN LOOP =========================================
    
    double av_pressure = 0.;
    double u_pressure = 0.;
    double av_temp = 0.;
    double u_temp = 0.;
    
    count_forces(); // function leap_frog() requries
    
    for (uint16_t ii=0; ii < timesteps; ii++)
    {
        // make algorithm step
        leap_frog();
        
        const double p = pressure();
        const double T = temperature();
        av_pressure += p;
        u_pressure += p*p;
        av_temp += T;
        u_temp += T*T;
        
        if (!(ii%steps_per_stats))
        {
            
        }
        else if (!(ii%steps_per_positions))
        {
            fwrite(global.x_arr,sizeof(double) * global.N, file_pos);
            fwrite(global.y_arr,sizeof(double) * global.N, file_pos);
            fwrite(global.z_arr,sizeof(double) * global.N, file_pos);
            
            fwrite(global.px_arr,sizeof(double) * global.N, file_mom);
            fwrite(global.py_arr,sizeof(double) * global.N, file_mom);
            fwrite(global.pz_arr,sizeof(double) * global.N, file_mom);
        }
    }
    
    
    //fprintf(file_pT,"\n","T","u(T)","p","u(p)");
    fprintf(file_pT,"%e\t%e\t%e\t%e\n",av_temp,u_temp,av_pressure,u_pressure);
    
    fclose(file_stats);
    fclose(file_pT);
    fclose(file_pos);
    fclose(file_mom);
    
//     free(pressure_arr);
//     free(sig_pressure_arr);
//     free(temp_arr);
//     free(sig_arr);
}



void free_mem()
{
    
    free(global.x_arr);
    free(global.y_arr);
    free(global.z_arr);
    
    free(global.px_arr);
    free(global.py_arr);
    free(global.pz_arr);
    
    free(global.fx_arr);
    free(global.fy_arr);
    free(global.fz_arr);
    
    if(!initial_x_arr) free(initial_x_arr);
    if(!initial_y_arr) free(initial_y_arr);
    if(!initial_z_arr) free(initial_z_arr);
    
    if (!wrk_arr1) free(wrk_arr1);
    if (!wrk_arr2) free(wrk_arr2);
    if (!wrk_arr3) free(wrk_arr3);
}